<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>

.sidenav {
	height: 100%;
	width: 20%;
  position: fixed;
  z-index: 1;
  top: 0;
  left: 0;
  background-color: #111;
  padding-top: 20px;
  float: left;
}

.sidenav a {
	padding: 6px 8px 6px 16px;
  text-decoration: none;
  color: #818181;
  display: block;
}

.sidenav a:hover {
	color: #f1f1f1;
}

.main {
	margin-left: 20%; /* Same as the width of the sidenav */
  /*width: 80%;*/
  padding: 0px 10px;
  float: left;
}

@media screen and (max-height: 450px) {
	.sidenav {padding-top: 15px;}
}
</style>
</head>
<body>
<div class="sidenav">
	<ul class='uk-nav uk-nav-default'><li><a href='#introduction'>Introduction</a></li><li><a href='#concept'>Concept</a></li><li><a href='#uses'>Uses</a></li><li><a href='#design'>Design</a></li><li><a href='#health-warnings'>Health warnings</a></li><li><a href='#installation'>Installation</a></li><li><a href='#dependencies'>&nbsp;&nbsp;Dependencies</a></li><li><a href='#upgrading'>Upgrading</a></li><li><a href='#uninstalling'>Uninstalling</a></li><li><a href='#overview'>Overview</a></li><li><a href='#usage'>Usage</a></li><li><a href='#documenting-the-migration'>&nbsp;&nbsp;Documenting the migration</a></li><li><a href='#snippets'>&nbsp;&nbsp;Snippets</a></li><li><a href='#populating-the-migration-page'>&nbsp;&nbsp;Populating the migration page</a></li><li><a href='#exporting-the-migration'>&nbsp;&nbsp;Exporting the migration</a></li><li><a href='#installing-the-migration'>&nbsp;&nbsp;Installing the migration</a></li><li><a href='#database-comparisons'>&nbsp;&nbsp;Database comparisons</a></li><li><a href='#creating-a-migration-from-a-comparison'>&nbsp;&nbsp;&nbsp;&nbsp;Creating a migration from a comparison</a></li></ul></div>
<div class="main" edit="dbMigrateAdditionalDetails">
<h1>DB Migrations module</h1>

<a name='introduction' href='#'></a><h2>Introduction</h2>

<p>ProcessWire is an outstanding content management system/framework owing to its flexibility, ease of use and outstanding API. However, it suffers from a common problem in database-oriented CMSs in that business logic may be explicitly or implicitly stored in the database rather than in code. This is particularly the case where it is used for a full-blooded app rather than just a simple CMS for a website. This is a shame because it is such a brilliant app-building tool.</p>

<p>The problem arises where the developer wishes to develop and test new or changed features in a development/test environment and then port those to the live environment. If the business logic is purely in the code and there are no database changes, then no issue arises, but if the changes involve database changes then typically the solution might be to test them, then replicate them manually (and hopefully accurately) in the live system. For large changes, this can be time-consuming and possibly error-prone. If a test environment is used as well as a development and live environment, then the problem is doubled.</p>

<p>The ProcessDbMigrate module is designed to make updating the test and/or live system as quick and error-free as possible.</p>

<a name='concept' href='#'></a><h2>Concept</h2>

<p>Purely code-based migration approaches effectively eschew the use of PW’s GUI development environment. This is technically perfectly sensible but restricts usage to those who are happy not to use the GUI. PW is a great tool for enabling less experienced developers to build great apps. This module is aimed at that group, who wish to use the PW GUI but still be able to do controlled and accurate migrations.</p>

<p>The concept of this module is therefore to achieve the following:</p>

<ol>
	<li>To allow development to take place (in a separate environment on a copy of the live database, or on a test database with the same structure) using the Admin UI. When finished, to permit a declarative approach to defining the migration and implementing it (again in the UI).</li>
	<li>To allow testing of the migration in a test environment on a copy of the live database.</li>
	<li>To allow roll-back of a migration if installation causes problems (ideally while testing rather than after implementation!).</li>
	<li>To provide a record of changes applied.</li>
	<li>Optionally, if changes are made directly on the live system (presumably simple, low-risk mods – although not best practice), to allow reverse migration to the development system in a similar fashion.</li>
	<li>To provide a database comparison tool which can (if wished) be used to create a draft migration for the differences between the databases.</li>
</ol>

<a name='uses' href='#'></a><h2>Uses</h2>

<p>The module has quite a wide range of applications. The original intention was just to handle the first of the examples below, but it has actually proved more useful than intended!</p>

<ol>
	<li>Developments where database changes are involved (as well as possibly code changes). The changes can be fully tested in a dev environment. Installation of the migration can then easily be checked in a test environment (on a copy of the live database). Installation in the live environment is then very quick (sync code changes and migration files then one click to install the migration) resulting in little or no down time.</li>
	<li>Updating of admin pages (not editable by general users), such as settings pages and help pages in the dev environment, then installing as a batch.</li>
	<li>Updating of language pages (e.g. by a simple migration of pages with 'template=language') – the associated files will be updated along with the pages.</li>
	<li>The selective reversion of parts of the database (by exporting migration data from a backup copy) for example where users have created numerous errors in the database.</li>
	<li>Comparison of two databases (within a defined scope of fields, templates and pages) and optional creation of migration to align them.</li>
	<li>Creation of a ‘blank canvas’ database from an existing working version. In other words, migrate the structure and all the necessary settings pages to a clean database.</li>
</ol>

<a name='design' href='#'></a><h2>Design</h2>

<p>The module has the following principal components all within the ProcessDbMigrate folder:</p>

<ul>
	<li>A PW module “ProcessDbMigrate” - the main autoload module which also provides the setup pages;</li>
	<li>A Page Class “DbMigrationPage” - the class for the DbMigration template which defines the migration pages;</li>
	<li>A bootstrap migration;</li>
	<li>A Page Class “DbComparisonPage” which extends DbMigrationPage (see separate section on comparisons for further information about this);</li>
	<li>A folder “RuntimeFields” containing php files dbMigrateActions.php, dbMigrateControl.php and dbMigrateReady.php along with javascript files dbMigrateActions.js, dbMigrateControl.js and dbMigrateReady.js. These runtime fields are used in migration pages to display status and provide controls;</li>
	<li>A module FieldtypeDbMigrateRuntime to implement the above runtime fields (pre v0.1.0 versions required the FieldtypeRuntimeOnly module).</li>
</ul>

<p>Migration definitions are held in .json files in the site/templates/DbMigrate /migrations/{migration name} directory. This directory contains up to 3 sub-directories - “new”, “old” and “archive”. The first two each may contain a file called a migration.json file, which defines the scope of the migration, and - once the migration been exported (for ‘new’) or installed (for ‘old’) – a file called data.json. The data.json file contains the data specifying the details of the installation (or uninstallation, in the case of the ‘old’ file). In addition, the “new” and “old” directories can contain “files” directories which hold the files associated with pages in the migration. The “old” directory may also contain an “orig-new-data.json” file for comparison purposes. The “archive” directory contains earlier versions of the “old” directory if migration definitions have changed. There may also be a file ‘lockfile.txt’ if the migration has been locked, which just holds a date &amp; time stamp of when it was locked.</p>

<p>The migration files described above are mirrored by pages of template "DbMigration" under a parent /{admin name/dbmigrations/ of template "DbMigrations". The mirroring happens in two ways:</p>

<ol>
	<li>If a new migration is created in the module (from the Setup -&gt; Database Migration menu – see below re installation), then initially no json files exist. The json files are created in the "new" directory, after the scope of the migration is defined on the page, by running "Export Data" from the eponymous button.</li>
	<li>If (new) json files exist, but there is no matching migration page, then a page is created by the module on accessing the Database Migration admin setup page. In this case, we are in the "target" database so there is no "Export Data" button, but instead "Install" and/or "Uninstall" buttons.</li>
</ol>

<p>Migrations therefore either view the current database environment as a “source” or a “target”. This is determined by whether the $page-&gt;meta(‘installable’) for the page is set or not. (The terms ‘installable’ and ‘exportable’ are used in this help file to differentiate the two types). Thus, if required, a knowledgeable superuser can change the type of a migration by adding or removing this meta item (e.g. in the Tracy console), but this is deliberately not made easy. (See further notes below on source and target databases).</p>

<p>Migration items may be either fields, templates or pages.</p>

<a name='health-warnings' href='#'></a><h2>Health warnings</h2>

<p>This module alters files and database elements. It is intended for superuser use only. <strong>Always take a backup before installing, updating or uninstalling it. Also take a backup before installing or uninstalling any migration.</strong></p>

<p><strong>Use at your own risk and test before implementing on the live system. Always have the same version of the module in source and target databases.</strong></p>

<a name='installation' href='#'></a><h2>Installation</h2>

<p>Initially install the module in your dev (source) environment.</p>

<ol>
	<li>
	<p>Place the whole folder in your site/modules/ directory.</p>
	</li>
	<li>
	<p>Install ProcessDbMigrate.</p>
	</li>
	<li>
	<p>Installing the module runs a ‘bootstrap’ migration which creates (system) templates called DbMigration, DbComparison and DbMigrations and parent pages in the admin named ‘dbmigrations’ and ‘dbcomparisons’, so make sure you are not using those already and rename if required. It also creates some (system) fields which include “dbMigrate” in their name. All templates and fields have the ‘dbMigrate’ tag and are set as ‘system’ (i.e. flags=8) so they do not muddy the standard menus. The bootstrap migration files are copied by the installation process to the site/templates/DbMigrate directory, which will be created if it does not exist.</p>
	</li>
	<li>
	<p>Configure the settings. Note that the settings are specific to the current database.</p>

	<ul>
		<li><em>Database name</em>: You can give the (current) database a name – in fact this is strongly recommended. If you do so, this name will be included as an item (‘sourceDb’) in the migration.json of any migration you create from this database. Any database with the same name will treat this migration as exportable rather than installable. This means, for example, that you can copy a production database and rename it to be the same as your original development database, so that any migrations sourced from that development database will be shown as exportable, not installable.</li>
		<li><em>Show database name in notice</em>: The current database name is notified (as a PW message) in every admin page (in case you forget which environment you are in!) – this will only be shown to superusers or users with the admin-dbMigrate permission.</li>
		<li><em>Exclude field types, fields, attributes</em>: You can exclude any fields or fieldtypes from page migrations that might cause problems and which are not needed (you will need to do this in each database). DbMigrateRuntime, RuntimeMarkup and RuntimeOnly fields are always excluded and do not need to be specified here. Similarly, you can exclude attributes from field and template migrations.</li>
		<li><em>Auto-install bootstrap</em>: If selected (the default), the bootstrap will be automatically installed on an upgrade.</li>
		<li><em>Prevent conflicting saves</em>: It is strongly recommended that you do not make any direct changes in the target database to any objects which are the subject of an "active" migration as this can cause problems if you need to uninstall the migration (the stored original state will not reflect the changes you made). This option (selected by default) prevents any such object changes in the target which may otherwise happen inadvertantly. Even if this option is not selected, a warning will be given when editing the an object which is a target of an "active" migration. (Note that an "active" migration is defined as an unlocked installable migration after first installation).</li>
	</ul>
	</li>
	<li>
	<p>Open the admin page “Setup -&gt; Database Migration” to create your first migration. You will see that one (“bootstrap”) is already installed and cannot be modified.</p>
	</li>
</ol>

<a name='dependencies' href='#'></a><h3>Dependencies</h3>

<p>Note that this module has only been tested on ProcessWire&gt;=3.0.148. A minimum of 3.0.165 is recommended.</p>

<a name='upgrading' href='#'></a><h2>Upgrading</h2>

<p>Place the code in the modules directory, replacing the existing files, then refresh modules in the database. Check whether the bootstrap is still showing as ‘installed’. It should have been installed automatically; if not, then install it.</p>

<p>If you are upgrading from a version earlier than 0.1.0, then the RuntimeOnly module will no longer be required for this module so, unless you use it elsewhere, you can uninstall it after the upgrade.</p>

<a name='uninstalling' href='#'></a><h2>Uninstalling</h2>

<p>Before uninstalling the module, all migration pages (other than the bootstrap) must be removed manually. Then, uninstalling the module uninstalls the bootstrap migration automatically; if that fails then the error will be reported, so that it can be fixed manually, before attempting to uninstall again.</p>

<a name='overview' href='#'></a><h2>Overview</h2>

<p>The pic below illustrates the DB Migrations page in the 'source' environment.</p>

<p><img alt="DB Migrations page in the 'source' environment" src="help/Setup_page_source_v3.jpg" /></p>

<p>The status of a migration (as a source page) can be 'pending' or 'exported'. 'Pending' means either that the migration data have not yet been exported or that the current export files differ from the source database.</p>

<p>To install on the live (or a separate test) environment, sync your source and target code environments. Then install the module in your target environment (from step 2 above). After installation of the module, on opening the admin page "Database Migrations", the individual Migration pages are created from the definitions in their respective /new/migration.json file.</p>

<p>If you do not have a separate test environment, one approach is to backup the dev database and restore a copy of the live (or test) database to the dev environment. Then install the module on the restored database (from step 2). However, a separate test environment is better in that it more accurately mimics the live one and is less likely to cause confusion.</p>

<p>Your new migration should be listed (as 'indeterminate' status) in the Database Migration admin page.</p>

<p>The pic below illustrates the Database Migrations page in the target environment.</p>

<p><img alt="DB Migrations page in the 'target' environment" src="help/Setup_page_target_v3.jpg" /></p>

<p>In a target environment, a migration status can usually be 'indeterminate', 'installed' or 'uninstalled'. 'Indeterminate' means either that the migration has not yet been installed (so no 'old' files containing the uninstall definition exist yet) or that the current state matches neither the 'new' or the 'old' state. 'Installed' means that the current state matches the 'new' definition and 'uninstalled' means that it matches the 'old' definition (i.e. it has been actively uninstalled rather than not yet installed). There is also a 'void' status which indicates that the migration achieves nothing.</p>

<p><strong>Note</strong> : If you can't remember whether you are working in a source or target environment (important! - you don't want to make developments in a test environment and then lose them!), make sure all databases have names in the module config and select “Show database name in notice”.</p>

<a name='usage' href='#'></a><h2>Usage</h2>

<p>TLDR:</p>

<ul>
	<li>Install the module in each database environment and enter the settings - give the databases different and meaningful names</li>
	<li>Specify your migration in the source database and “export” it</li>
	<li>Sync your code environments</li>
	<li>Install the migration in your target environment</li>
</ul>

<a name='documenting-the-migration' href='#'></a><h3>Documenting the migration</h3>

<p>When carrying out development work, keep a note of what fields, templates and pages you have added, changed or removed. The module does not track this for you – it is a declarative approach, not a macro recorder. Also, it does not handle other components such as Hanna codes and Formbuilder forms. These come equipped with their own export/import functions, so use those (see "Snippets").</p>

<p>The best way to document the changes is to create and update a migration page as you go along, rather than keep a separate note of changed components. The migration page also allows you to document the migration using a rich text box, and it is recommended that you use this to add notes about the migration, including any pre- or post-migration checks and procedures to be carried out. (You may carry out some procedures automatically – see the section on hooks).</p>

<a name='snippets' href='#'></a><h3>Snippets</h3>

<p>On the migration page, you can add any number of "snippets". These snippets do not do anything, but can be a convenient place to store (for example) Hanna code exports for pasting into the target environment and they help to make the page a comprehensive record of the migration.</p>

<p>You can also use snippets for php code to run before or after installation (or uninstallation). The code can then be copied into Tracy’s console log and run from there. Use the description box in the snippet to indicate when the code should be run. For example, say you have changed an address field to split out the post code into a separate field. The migration definition will specify the new field and the changed template. The code snippet (to be run after installation) will then include the code to extract postcodes and place them in the new field.</p>

<p>Alternatively, if you want code to run automatically, you can use hooks – see the separate section on this.</p>

<a name='populating-the-migration-page' href='#'></a><h3>Populating the migration page</h3>

<p>See example below:</p>

<p><img alt="Migration_page_source_full_v4.jpg" src="help/Migration_page_source_full_v4.jpg" /></p>

<p>On your migration page, enter the names of new and changed fields and templates, and enter the paths of pages (as /path/to/pagename/). Selectors may be used instead of paths or names (see box below). Note that entry of names and paths is in text fields, not using dropdowns, as names, paths and ids may be different in the source and target systems – there is limited real-time checking of these. If an item has a different name in the target database then provide it in the 'old name' box, otherwise leave that blank.</p>

<p>Note that <strong>the sequence is very important</strong> – if items are dependent on other items, they must be declared in the correct order for installation (when uninstalling, the order is automatically reversed and 'new' and 'removed' are swapped). Note particularly for Repeater and PageTable field types, you need to define the components in the right order – e.g. the template before the field that uses it, in the case of new/changed components. You do not need to declare components that are unchanged.</p>

<hr />
<p><strong><em>Selectors</em></strong>:</p>

<p><em>Only one object name is permitted per item, however objects may be selected by using a selector rather than individual names or paths. Selectors operate as follows:</em></p>

<ol>
	<li><em>For ‘new’ and ‘changed’ objects, the selector identifies the objects in the</em> <strong><em>source environment only</em></strong>. <em>If these objects also exist in the target environment, they will be changed, otherwise they will be created (but avoid ambiguity – see 4 below). There is no possibility of matching objects whose name (or path) has changed.</em></li>
	<li><em>For ‘removed’ objects, the selector identifies objects in the <strong>target environment only</strong>.</em></li>
	<li><em>The use of “sort=path” is permitted in page selectors, even though this normally has no effect. If it is used, the pages will be sorted in parent-child order, using the ‘natural’ sort order (e.g. XYZ100 is greater than XYZ20). This means that parents will be installed before children. For ‘removed’ pages, the order is automatically reversed so that children are deleted before parents (there is no need to use the inverse: sort=-path).</em></li>
	<li><strong><em>Important</em></strong>: <em>Make sure that the scope of a selector works in both the source and target environments, i.e.:</em></li>
</ol>

<ul>
	<li><em>a. If the action is ‘changed’ then it must be unambiguous – i.e. all the names/paths of the selection of objects must be the same in both environments. Do not use ‘changed’ with an ambiguous selector because, although it may appear to install correctly, it will not be possible to uninstall it - any moved or removed pages will not be removed and uninstallation will fail.</em></li>
	<li><em>b. If the action is ‘new’ then the selection of objects should only exist in the source environment;</em></li>
	<li><em>c. If the action is ‘removed’ then the selection of objects must only exist in the target environment.</em></li>
</ul>

<p><em>Do make sure that your selector works in the source and/or target environments, as appropriate, before implementing it (TracyDebugger is great for this).</em> <strong><em>A typical error is forgetting to add “include=…”.</em></strong></p>

<p><strong><em>Note</em></strong> <em>that if your selectors encompass a large number of objects, processing time may be extended.</em></p>

<hr />
<p>You can limit the scope of changes to pages by restricting the fields to those specified in the "Restrict Fields" box. This restriction will apply to all pages within the scope of this migration, but only this migration; if you wish to exclude certain fields or fieldtypes globally, enter these in the module configuration.</p>

<p>You can preview the changes at any time, even before you export them, this will help you ensure that the data you are proposing to migrate is correct. You can also test as you go along, if you wish, and add to the migration in stages.</p>

<p>Note that migration pages just define the scope of the migration. It is entirely feasible for other parts of the dev database to be changed which are outside this scope and which will therefore not be migrated. If you are doing this intentionally, be careful to ensure that the scope of your migrations do not overlap, otherwise you may inadvertently make changes that you do not wish to do yet.</p>

<p>When saving a migration page in the source database, the system will warn you if the current migration scope overlaps with other exportable migrations. <strong>Do not proceed to install such overlapping migrations</strong>. They will interfere with each other, even if they are not making conflicting changes – once one has been installed, installing the other will create an ‘old’ json file that reflects changes made by the first, so (for example) attempting to uninstall this second installation will appear not to be successful as it will not be able uninstall the changes made by the first. If two migrations necessarily overlap, then the correct process is to install the first one and lock it before installing the second migration. Locking a migration is carried out in the source database. This creates a lockfile in the migration's directory which needs to be sync’d to the target environment to lock the migration there.</p>

<a name='exporting-the-migration' href='#'></a><h3>Exporting the migration</h3>

<p>When ready to test (or migrate to live), click the "Export Data" button on the migration page. Some informative messages should result. Your codebase will now contain the json files in site/templates/DbMigrate/migration/{your migration page name} – you can inspect them if you wish in your IDE.</p>

<p>Sync the code files with your test/live environment (or restore the test database to your dev environment, <em>making sure you back up the dev database first</em>). In the test/live database, install the module as described above, if necessary, and go to the Database Migration admin page. You should see your new migration listed.</p>

<a name='installing-the-migration' href='#'></a><h3>Installing the migration</h3>

<p>Go to the migration page. Before installing, you can use the "preview" button to see what changes will be implemented. If you are happy, click "Install". This should result in various messages and maybe some errors, if the migration was not able to complete fully (see section below for how to deal with partial migrations). See example of the migration page in 'installation' mode below:</p>

<p><img alt="Migration_page_target.jpg" src="help/Migration_page_target.jpg" /></p>

<p>and an example preview:</p>

<p><img alt="Preview_differences_selector.jpg" src="help/Preview_differences_selector.jpg" /></p>

<p>Note that you will now have the following files:</p>

<ul>
	<li>A folder “old” in site/templates/DbMigrate/migration/{your migration page name} – this contains (as file data.json) the definition of the database (within the migration scope) before the migration was installed and is used for roll-back (uninstall). It also has the migration page definition that was used for the installation (as /old/migration.json) and the data.json file that was used (as old/orig-new-data.json) – these are used to detect whether the migration scope definition has changed since installation. The ‘old’ folder is used for uninstalling. If the migration scope is changed (in the source environment) then it cannot be installed in the target environment without first uninstalling the previous version of the migration scope and then installing the new version – in this way the ‘old’ files will reflect the revised scope.</li>
	<li>A folder site/assets/cache/dbMigrations has the json files defining the current state of the database (within the scope of the migration)</li>
</ul>

<p>To uninstall a migration, click the "Uninstall" button (again, you can preview beforehand). This should revert the database to the initial state, but again there may be reasons why this cannot complete fully – see the notes below.</p>

<p>NB When re-installing migrations, if the migration definition has changed, the system will require you to uninstall first - otherwise the “old” data.json will not properly reflect the new scope, affecting any future uninstallation. In these circumstances, a backup copy of the “old” directory is created in the archive directory.</p>

<a name='database-comparisons' href='#'></a><h3>Database comparisons</h3>

<p>Comparisons work in a similar way to migrations. First, make sure you are in the database which you wish to be the ‘source’ of the comparison (usually the development database – this will be assumed for the rest of this narrative). Also, make sure that your database is named (on the module settings page).</p>

<p>On the Database Migrations page, select the “Add New DbComparison” button. On the DbComparison page you can add a summary and a number of ‘comparison items’. Note that comparison items just comprise an object type (field/template/page) and a name/selector. These items define the scope of the comparison. In theory, you can compare entire databases by using a selector “id&gt;0” for each of pages, fields and templates. However, this is likely to be quite resource-hungry if the database is large, so it is better to use a scope that is more selective. In any case, you will probably want to exclude migration and database comparisons from the scope, together with the related repeater pages, otherwise it can be a bit self-referential (but shouldn’t crash). The example below compares all templates and fields (but not pages):</p>

<p><img alt="Comparison - source" src="help/Comparison_source.jpg" /></p>

<p>After saving the page, click ‘export data’ (or preview first) and sync the templates/DbMigrate/Comparison/{name}/ directory to your target environment. Then go to the target database and open the comparison page (you may need to refresh the comparisons summary page first). Here you will see two ‘migrate actions’:</p>

<ul>
	<li>click ‘Compare Database’ to see the differences between the current database and the source;</li>
	<li>click ‘Create a Draft Migration For This Comparison’ to do exactly that (see below).</li>
</ul>

<a name='creating-a-migration-from-a-comparison' href='#'></a><h4>Creating a migration from a comparison</h4>

<p>This process is only semi-automated. The system will work out the scope of the required migration (i.e. what fields, templates and pages require adding/changing/removing) but will not identify any dependencies, so the sequence of migration items might be wrong. Also, it will not identify any name changes – if names are different then this will result in a ‘new’ and a ‘removed’ item.</p>

<p>Therefore, clicking the ‘create draft migration’ button does only create a draft. You need to</p>

<ul>
	<li>sync the migration files to the source environment;</li>
	<li>review the migration page in the source database, resequencing the items as necessary.</li>
	<li>For name changes, you can alter the ‘new’ item to be ‘changed’ and set the ‘old name’ to be the name of the ‘removed’ item; then delete the removed item (although the migration should still work without doing this, it is neater).</li>
	<li>then export the migration from the source environment and install it in the usual way.</li>
</ul>

<p>If you have selected the whole database for comparison, then rather than create a migration, you are probably better just to do a backup and restore</p></div>

</body>
</html>